##################################
#### WITH NO EXTRA WHITESPACE ####
##################################

 elasticlunr body > .navbar .brand { float: left; text-shadow: rgba(255, 255, 255, 0.0980392) 0px 1px 0px, rgba(255, 255, 255, 0.4) 0px 0px 30px; color: white; margin-left: 0px; font-weight: normal; } .bs-docs-sidenav.affix { box-shadow: 0 0 20px 1px rgba(0, 0, 0, 0.5); z-index: 10; } .bs-docs-sidenav i { width: 8px; height: 8px; padding: 0px; margin: 0px; display: inline-block; margin-right: 0.5em; } .bs-docs-sidenav > li > a { word-wrap: break-word; } .bs-docs-sidenav > li:first-child > a { border-top-right-radius: 6px; border-top-left-radius: 6px; } code[class*='language-'], pre[class*='language-'] { color: black; text-shadow: 0 1px white; font-family: Consolas, Monaco, 'Andale Mono', monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; -moz-tab-size: 4; -o-tab-size: 4; tab-size: 4; -webkit-hyphens: none; -moz-hyphens: none; -ms-hyphens: none; hyphens: none; } pre[class*='language-'] { padding: 1em; margin: 0.5em 0; overflow: auto; } :not(pre) > code[class*='language-'], pre[class*='language-'] { background: #f5f2f0; } :not(pre) > code[class*='language-'] { padding: 0.1em; border-radius: 0.3em; } .token.comment, .token.prolog, .token.doctype, .token.cdata { color: slategray; } .token.punctuation { color: #999; } .namespace { opacity: 0.7; } .token.property, .token.tag, .token.boolean, .token.number { color: #905; } .token.selector, .token.attr-name, .token.string { color: #690; } .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string { color: #a67f59; background: hsla(0, 0%, 100%, 0.5); } .token.atrule, .token.attr-value, .token.keyword { color: #07a; } .token.regex, .token.important { color: #e90; } .token.important { font-weight: bold; } .token.entity { cursor: help; } div.description { margin: 14px 0; padding-top: 14px; border-bottom: 1px solid #eee; } .tags { } .ctx-type { display: inline-block; margin-right: 0.5em; //- float:right; margin-top:8px } footer iframe { vertical-align: middle; } Doxx elasticlunr Main configuration.js document_store.js elasticlunr.js event_emitter.js index.js inverted_index.js pipeline.js sorted_set.js stemmer.js stop_word_filter.js tokenizer.js trimmer.js utils.js Elasticlunr.js Elasticlunr.js is a lightweight full-text search engine developed in JavaScript for browser search and offline search. Elasticlunr.js is developed based on Lunr.js, but more flexible than lunr.js. Elasticlunr.js provides Query-Time boosting, field search, more rational scoring/ranking methodology, fast computation speed and so on. Elasticlunr.js is a bit like Solr, but much smaller and not as bright, but also provide flexible configuration, query-time boosting, field search and other features. Why You Need Lightweight Offline Search? In some system, you don&#39;t want to deploy any complex full-text search engine (such as Lucence, Elasticsearch, Sphinx, etc.), you only want to provide some static web pages and provide search functionality , then you could build index in previous and load index in client side(such as Browser). Provide offline search functionality. For some documents, user usually download these documents, you could build index and put index in the documents package, then provide offline search functionality. For some limited or restricted network, such WAN or LAN, offline search is a better choice. For mobile device, Iphone or Android phone, network traffic maybe very expensive, then provide offline search is a good choice. If you want to provide search functionality in your Node.js system, and you don&#39;t want to use a complex system, or you only need to support thousands of documents, then Elasticlunr.js is what you want to use. Key Features Comparing with Lunr.js Query-Time Boosting , you don&#39;t need to setup boosting weight in index building procedure, Query-Time Boosting make it more flexible that you could try different boosting scheme. More Rational Scoring Mechanism , Elasticlunr.js use quite the same scoring mechanism as Elasticsearch, and also this scoring mechanism is used by lucene. Field-Search , you could choose which field to index and which field to search. Boolean Model , you could set which field to search and the boolean model for each query token, such as &quot;OR&quot;, &quot;AND&quot;. Combined Boolean Model, TF/IDF Model and the Vector Space Model , make the results ranking more reliable. Fast , Elasticlunr.js removed TokenCorpus and Vector from lunr.js, by using combined model there is no need to compute the vector of a document and query string to compute similarity of query and matched document, this improve the search speed significantly. Small Index Size , Elasticlunr.js did not store TokenCorpus because there is no need to compute query vector and document vector, then the index file is small, and also user could choose if they need to store the origianl JSON doc, if user care more about the index size, they could choose not store the original JSON doc, this could reduce the index size significantly. This is especially helpful when elasticlunr.js is used as offline search. The index size is about half size of lunr.js index file. Example A very simple search index can be created using the following scripts: var index = elasticlunr(function () { this.addField(&#39;title&#39;); this.addField(&#39;body&#39;); this.setRef(&#39;id&#39;); }); Adding documents to the index is as simple as: var doc1 = { &quot;id&quot;: 1, &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;, &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot; } var doc2 = { &quot;id&quot;: 2, &quot;title&quot;: &quot;Oracle released its profit report of 2015&quot;, &quot;body&quot;: &quot;As expected, Oracle released its profit report of 2015, during the good sales of database and hardware, Oracle&#39;s profit of 2015 reached 12.5 Billion.&quot; } index.addDoc(doc1); index.addDoc(doc2); Then searching is as simple: index.search(&quot;Oracle database profit&quot;); Also, you could do query-time boosting by passing in a configuration. index.search(&quot;Oracle database profit&quot;, { fields: { title: {boost: 2}, body: {boost: 1} } }); This returns a list of matching documents with a score of how closely they match the search query: [{ &quot;ref&quot;: 1, &quot;score&quot;: 0.5376053707962494 }, { &quot;ref&quot;: 2, &quot;score&quot;: 0.5237481076838757 }] If user do not want to store the original JSON documents, they could use the following setting: var index = elasticlunr(function () { this.addField(&#39;title&#39;); this.addField(&#39;body&#39;); this.setRef(&#39;id&#39;); this.saveDocument(false); }); Then elasticlunr.js will not store the JSON documents, this will reduce the index size, but also bring some inconvenience such as update a document or delete a document by document id or reference. Actually most of the time user will not udpate or delete a document from index. API documentation is available, as well as a full working example . Description Elasticlunr.js is developed based on Lunr.js, but more flexible than lunr.js. Elasticlunr.js provides Query-Time Boosting, Field Search, more rational scoring/ranking methodology, flexible configuration and so on. A bit like Solr, but much smaller and not as bright, but also provide flexible configuration, query-time boosting, field search, etc. Installation Simply include the elasticlunr.js source file in the page that you want to use it. Elasticlunr.js is supported in all modern browsers. Browsers that do not support ES5 will require a JavaScript shim for Elasticlunr.js to work. You can either use Augment.js , ES5-Shim or any library that patches old browsers to provide an ES5 compatible JavaScript environment. Documentation This part only contain important apects of elasticlunr.js, for the whole documentation, please go to API documentation . 1. Build Index When you first create a index instance, you need to specify which field you want to index. If you did not specify which field to index, then no field will be searchable for your documents. You could specify fields by: var index = elasticlunr(function () { this.addField(&#39;title&#39;); this.addField(&#39;body&#39;); this.setRef(&#39;id&#39;); }); You could also set the document reference by this.setRef(&#39;id&#39;) , if you did not set document ref, elasticlunr.js will use &#39;id&#39; as default. You could do the above index setup as followings: var index = elasticlunr(); index.addField(&#39;title&#39;); index.addField(&#39;body&#39;); index.setRef(&#39;id&#39;); Also you could choose not store the original JSON document to reduce the index size by: var index = elasticlunr(); index.addField(&#39;title&#39;); index.addField(&#39;body&#39;); index.setRef(&#39;id&#39;); index.saveDocument(false); 2. Add document to index Add document to index is very simple, just prepare you document in JSON format, then add it to index. var doc1 = { &quot;id&quot;: 1, &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;, &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot; } var doc2 = { &quot;id&quot;: 2, &quot;title&quot;: &quot;Oracle released its profit report of 2015&quot;, &quot;body&quot;: &quot;As expected, Oracle released its profit report of 2015, during the good sales of database and hardware, Oracle&#39;s profit of 2015 reached 12.5 Billion.&quot; } index.addDoc(doc1); index.addDoc(doc2); If your JSON document contains field that not configured in index, then that field will not be indexed, which means that field is not searchable. 3. Remove document from index Elasticlunr.js support remove a document from index, just provide JSON document to elasticlunr.Index.prototype.removeDoc() function. For example: var doc = { &quot;id&quot;: 1, &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;, &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot; } index.removeDoc(doc); Remove a document will remove each token of that document&#39;s each field from field-specified inverted index. 4. Update a document in index Elasticlunr.js support update a document in index, just provide JSON document to elasticlunr.Index.prototype.update() function. For example: var doc = { &quot;id&quot;: 1, &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;, &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot; } index.update(doc); 5. Query from Index Elasticlunr.js provides flexible query configuration, supports query-time boosting and Boolean logic setting. You could setup a configuration tell elasticlunr.js how to do query-time boosting, which field to search in, how to do the boolean logic. Or you could just use it by simply provide a query string, this will aslo works perfectly because the scoring mechanism is very efficient. 5.1 Simple Query Because elasticlunr.js has a very perfect scoring mechanism, so for most of your requirement, simple search would be easy to meet your requirement. index.search(&quot;Oracle database profit&quot;); Output is a results array, each element of results array is an Object contain a ref field and a score field. ref is the document reference. score is the similarity measurement. Results array is sorted descent by score . 5.2 Configuration Query 5.2.1 Query-Time Boosting Setup which fields to search in by passing in a JSON configuration, and setup boosting for each search field. If you setup this configuration, then elasticlunr.js will only search the query string in the specified fields with boosting weight. The scoring mechanism used in elasticlunr.js is very complex , please goto details for more information. index.search(&quot;Oracle database profit&quot;, { fields: { title: {boost: 2}, body: {boost: 1} } }); 5.2.2 Boolean Model Elasticlunr.js also support boolean logic setting, if no boolean logic is setted, elasticlunr.js use &quot;OR&quot; logic defaulty. By &quot;OR&quot; default logic, elasticlunr.js could reach a high Recall . index.search(&quot;Oracle database profit&quot;, { fields: { title: {boost: 2}, body: {boost: 1} }, bool: &quot;OR&quot; }); Boolean model could be setted by global level such as the above setting or it could be setted by field level, if both global and field level contains a &quot;bool&quot; setting, field level setting will overwrite the global setting. index.search(&quot;Oracle database profit&quot;, { fields: { title: {boost: 2, bool: &quot;AND&quot;}, body: {boost: 1} }, bool: &quot;OR&quot; }); The above setting will search title field by AND model and other fields by &quot;OR&quot; model. Currently if you search in multiply fields, resutls from each field will be merged together to give the query results. In the future elasticlunr will support configuration that user could set how to combine the results from each field, such as &quot;most_field&quot; or &quot;top_field&quot;. 5.2.3 Token Expandation Sometimes user want to expand a query token to increase RECALL , then user could set expand model to true by configuration, default is false . For example, user query token is &quot;micro&quot;, and assume &quot;microwave&quot; and &quot;microscope&quot; are in the index, then is user choose expand the query token &quot;micro&quot; to increase RECALL , both &quot;microwave&quot; and &quot;microscope&quot; will be returned and search in the index. The query results from expanded tokens are penalized because they are not exactly the same as the query token. index.search(&quot;micro&quot;, { fields: { title: {boost: 2, bool: &quot;AND&quot;}, body: {boost: 1} }, bool: &quot;OR&quot;, expand: true }); Field level expand configuration will overwrite global expand configuration. index.search(&quot;micro&quot;, { fields: { title: { boost: 2, bool: &quot;AND&quot;, expand: false }, body: {boost: 1} }, bool: &quot;OR&quot;, expand: true }); 6. Add customized stop words Elasticlunr.js contains some default stop words of English, such as: a about an all also and any but the ... Defaultly elasticlunr.js contains 120 stop words, user could decide not use these default stop words or add customized stop words. 6.1 Remove default stop words You could remove default stop words simply as: elasticlunr.clearStopWords(); 6.2 Add customized stop words User could add a list of customized stop words. var customized_stop_words = [&#39;an&#39;, &#39;hello&#39;, &#39;xyzabc&#39;]; elasticlunr.addStopWords(customized_stop_words); 7. Use elasticlunr in Node.js Elasticlunr support Node.js, you could use elastilunr in node.js as a node-module. Install elasticlunr by: npm install elasticlunr then in your node.js project or in node.js console: var elasticlunr = require(&#39;elasticlunr&#39;); var index = elasticlunr(function () { this.addField(&#39;title&#39;) this.addField(&#39;body&#39;) }); var doc1 = { &quot;id&quot;: 1, &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;, &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot; } var doc2 = { &quot;id&quot;: 2, &quot;title&quot;: &quot;Oracle released its profit report of 2015&quot;, &quot;body&quot;: &quot;As expected, Oracle released its profit report of 2015, during the good sales of database and hardware, Oracle&#39;s profit of 2015 reached 12.5 Billion.&quot; } index.addDoc(doc1); index.addDoc(doc2); index.search(&quot;Oracle database profit&quot;); Other Languages Default supported language of elasticlunr.js is English, if you want to use elasticlunr.js to index other language documents, then you need to use elasticlunr.js combined with lunr-languages . Other languages example in Browser Suppose you are using elasticlunr.js in browser for other languages, you could download the corresponding language support from lunr-languages , then include the scripts as: &lt;script src=&quot;lunr.stemmer.support.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;lunr.de.js&quot;&gt;&lt;/script&gt; then, you could use elasticlunr.js as normal: var index = elasticlunr(function () { // use the language (de) this.use(elasticlunr.de); // then, the normal elasticlunr index initialization this.addField(&#39;title&#39;) this.addField(&#39;body&#39;) }); Pay attention to the special code: this.use(elasticlunr.de); If you are using other language, such as es (Spanish), download the corresponding lunr.es.js file and lunr.stemmer.support.js , and change the above line to: this.use(elasticlunr.es); Other languages example in Node.js Suppose you are using elasticlunr.js in Node.js for other languages, you could download the corresponding language support from lunr-languages , put the files lunr.es.js file and lunr.stemmer.support.js in your project, then in your Node.js module, use elasticlunr.js as: var elasticlunr = require(&#39;elasticlunr&#39;); require(&#39;./lunr.stemmer.support.js&#39;)(elasticlunr); require(&#39;./lunr.de.js&#39;)(elasticlunr); var index = elasticlunr(function () { // use the language (de) this.use(elasticlunr.de); // then, the normal elasticlunr index initialization this.addField(&#39;title&#39;) this.addField(&#39;body&#39;) }); For more details, please go to lunr-languages . Contributing See the CONTRIBUTING.mdown file . Documentation generated with Doxx created by Francois-Guillaume Ribreau Doxx is sponsored by Bringr and Redsmin Theme borrowed from Twitter Bootstrap /** * Prism: Lightweight, robust, elegant syntax highlighting * MIT license http://www.opensource.org/licenses/mit-license.php/ * @author Lea Verou http://lea.verou.me */ (function() { var e = /\blang(?:uage)?-(?!\*)(\w+)\b/i, t = (self.Prism = { util: { type: function(e) { return Object.prototype.toString .call(e) .match(/\[object (\w+)\]/)[1]; }, clone: function(e) { var n = t.util.type(e); switch (n) { case 'Object': var r = {}; for (var i in e) e.hasOwnProperty(i) && (r[i] = t.util.clone(e[i])); return r; case 'Array': return e.slice(); } return e; } }, languages: { extend: function(e, n) { var r = t.util.clone(t.languages[e]); for (var i in n) r[i] = n[i]; return r; }, insertBefore: function(e, n, r, i) { i = i || t.languages; var s = i[e], o = {}; for (var u in s) if (s.hasOwnProperty(u)) { if (u == n) for (var a in r) r.hasOwnProperty(a) && (o[a] = r[a]); o[u] = s[u]; } return (i[e] = o); }, DFS: function(e, n) { for (var r in e) { n.call(e, r, e[r]); t.util.type(e) === 'Object' && t.languages.DFS(e[r], n); } } }, highlightAll: function(e, n) { var r = document.querySelectorAll( 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' ); for (var i = 0, s; (s = r[i++]); ) t.highlightElement(s, e === !0, n); }, highlightElement: function(r, i, s) { var o, u, a = r; while (a && !e.test(a.className)) a = a.parentNode; if (a) { o = (a.className.match(e) || [, ''])[1]; u = t.languages[o]; } if (!u) return; r.className = r.className.replace(e, '').replace(/\s+/g, ' ') + ' language-' + o; a = r.parentNode; /pre/i.test(a.nodeName) && (a.className = a.className.replace(e, '').replace(/\s+/g, ' ') + ' language-' + o); var f = r.textContent; if (!f) return; f = f .replace(/&/g, '&amp;') .replace(/ </g, '&lt;') .replace(/>/g, '&gt;') .replace(/\u00a0/g, ' '); var l = { element: r, language: o, grammar: u, code: f }; t.hooks.run('before-highlight', l); if (i && self.Worker) { var c = new Worker(t.filename); c.onmessage = function(e) { l.highlightedCode = n.stringify(JSON.parse(e.data)); l.element.innerHTML = l.highlightedCode; s && s.call(l.element); t.hooks.run('after-highlight', l); }; c.postMessage( JSON.stringify({ language: l.language, code: l.code }) ); } else { l.highlightedCode = t.highlight(l.code, l.grammar); l.element.innerHTML = l.highlightedCode; s && s.call(r); t.hooks.run('after-highlight', l); } }, highlight: function(e, r) { return n.stringify(t.tokenize(e, r)); }, tokenize: function(e, n) { var r = t.Token, i = [e], s = n.rest; if (s) { for (var o in s) n[o] = s[o]; delete n.rest; } e: for (var o in n) { if (!n.hasOwnProperty(o) || !n[o]) continue; var u = n[o], a = u.inside, f = !!u.lookbehind || 0; u = u.pattern || u; for (var l = 0; l < i.length; l++) { var c = i[l]; if (i.length > e.length) break e; if (c instanceof r) continue; u.lastIndex = 0; var h = u.exec(c); if (h) { f && (f = h[1].length); var p = h.index - 1 + f, h = h[0].slice(f), d = h.length, v = p + d, m = c.slice(0, p + 1), g = c.slice(v + 1), y = [l, 1]; m && y.push(m); var b = new r(o, a ? t.tokenize(h, a) : h); y.push(b); g && y.push(g); Array.prototype.splice.apply(i, y); } } } return i; }, hooks: { all: {}, add: function(e, n) { var r = t.hooks.all; r[e] = r[e] || []; r[e].push(n); }, run: function(e, n) { var r = t.hooks.all[e]; if (!r || !r.length) return; for (var i = 0, s; (s = r[i++]); ) s(n); } } }), n = (t.Token = function(e, t) { this.type = e; this.content = t; }); n.stringify = function(e) { if (typeof e == 'string') return e; if (Object.prototype.toString.call(e) == '[object Array]') { for (var r = 0; r < e.length; r++) e[r] = n.stringify(e[r]); return e.join(''); } var i = { type: e.type, content: n.stringify(e.content), tag: 'span', classes: ['token', e.type], attributes: {} }; i.type == 'comment' && (i.attributes.spellcheck = 'true'); t.hooks.run('wrap', i); var s = ''; for (var o in i.attributes) s += o + '="' + (i.attributes[o] || '') + '"'; return ( ' <' + i.tag + ' class="' + i.classes.join(' ') + '" ' + s + '>' + i.content + ' </' + i.tag + '>' ); }; if (!self.document) { self.addEventListener( 'message', function(e) { var n = JSON.parse(e.data), r = n.language, i = n.code; self.postMessage(JSON.stringify(t.tokenize(i, t.languages[r]))); self.close(); }, !1 ); return; } var r = document.getElementsByTagName('script'); r = r[r.length - 1]; if (r) { t.filename = r.src; document.addEventListener && !r.hasAttribute('data-manual') && document.addEventListener('DOMContentLoaded', t.highlightAll); } })(); Prism.languages.markup = { comment: /&lt;!--[\w\W]*?--(&gt;|&gt;)/g, prolog: /&lt;\?.+?\?&gt;/, doctype: /&lt;!DOCTYPE.+?&gt;/, cdata: /&lt;!\[CDATA\[[\w\W]+?]]&gt;/i, tag: { pattern: /&lt;\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|\w+))?\s*)*\/?&gt;/gi, inside: { tag: { pattern: /^&lt;\/?[\w:-]+/i, inside: { punctuation: /^&lt;\/?/, namespace: /^[\w-]+?:/ } }, 'attr-value': { pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi, inside: { punctuation: /=|&gt;|"/g } }, punctuation: /\/?&gt;/g, 'attr-name': { pattern: /[\w:-]+/g, inside: { namespace: /^[\w-]+?:/ } } } }, entity: /&amp;#?[\da-z]{1,8};/gi }; Prism.hooks.add('wrap', function(e) { e.type === 'entity' && (e.attributes.title = e.content.replace(/&amp;/, '&')); }); Prism.languages.css = { comment: /\/\*[\w\W]*?\*\//g, atrule: /@[\w-]+?(\s+[^;{]+)?(?=\s*{|\s*;)/gi, url: /url\((["']?).*?\1\)/gi, selector: /[^\{\}\s][^\{\}]*(?=\s*\{)/g, property: /(\b|\B)[a-z-]+(?=\s*:)/gi, string: /("|')(\\?.)*?\1/g, important: /\B!important\b/gi, ignore: /&(lt|gt|amp);/gi, punctuation: /[\{\};:]/g }; Prism.languages.markup && Prism.languages.insertBefore('markup', 'tag', { style: { pattern: /(&lt;| <)style[\w\W]*?(>|&gt;)[\w\W]*?(&lt;| <)\/style(>|&gt;)/gi, inside: { tag: { pattern: /(&lt;| <)style[\w\W]*?(>|&gt;)|(&lt;| <)\/style(>|&gt;)/gi, inside: Prism.languages.markup.tag.inside }, rest: Prism.languages.css } } }); Prism.languages.clike = { comment: { pattern: /(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*?(\r?\n|$))/g, lookbehind: !0 }, string: /("|')(\\?.)*?\1/g, keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|catch|finally|null|break|continue)\b/g, boolean: /\b(true|false)\b/g, number: /\b-?(0x)?\d*\.?[\da-f]+\b/g, operator: /[-+]{1,2}|!|=?&lt;|=?&gt;|={1,2}|(&amp;){1,2}|\|?\||\?|\*|\//g, ignore: /&(lt|gt|amp);/gi, punctuation: /[{}[\];(),.:]/g }; Prism.languages.javascript = Prism.languages.extend('clike', { keyword: /\b(var|let|if|else|while|do|for|return|in|instanceof|function|new|with|typeof|try|catch|finally|null|break|continue)\b/g, number: /\b(-?(0x)?\d*\.?[\da-f]+|NaN|-?Infinity)\b/g }); Prism.languages.insertBefore('javascript', 'keyword', { regex: { pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g, lookbehind: !0 } }); Prism.languages.markup && Prism.languages.insertBefore('markup', 'tag', { script: { pattern: /(&lt;| <)script[\w\W]*?(>|&gt;)[\w\W]*?(&lt;| <)\/script(>|&gt;)/gi, inside: { tag: { pattern: /(&lt;| <)script[\w\W]*?(>|&gt;)|(&lt;| <)\/script(>|&gt;)/gi, inside: Prism.languages.markup.tag.inside }, rest: Prism.languages.javascript } } }); $(function() { var $window = $(window); $('.scrollspy .nav').affix({ offset: { top: function() { return $window.width() <= 980 ? 480 : 400; }, bottom: 50 } }); }); 

####################################
#### WITH EXTRANEOUS WHITESPACE ####
####################################


 
   
     
     elasticlunr 
     
     
     
     
      body > .navbar .brand {
        float: left;
        text-shadow: rgba(255, 255, 255, 0.0980392) 0px 1px 0px,
          rgba(255, 255, 255, 0.4) 0px 0px 30px;
        color: white;
        margin-left: 0px;
        font-weight: normal;
      }

      .bs-docs-sidenav.affix {
        box-shadow: 0 0 20px 1px rgba(0, 0, 0, 0.5);
        z-index: 10;
      }

      .bs-docs-sidenav i {
        width: 8px;
        height: 8px;
        padding: 0px;
        margin: 0px;
        display: inline-block;
        margin-right: 0.5em;
      }

      .bs-docs-sidenav > li > a {
        word-wrap: break-word;
      }

      .bs-docs-sidenav > li:first-child > a {
        border-top-right-radius: 6px;
        border-top-left-radius: 6px;
      }

      code[class*='language-'],
      pre[class*='language-'] {
        color: black;
        text-shadow: 0 1px white;
        font-family: Consolas, Monaco, 'Andale Mono', monospace;
        direction: ltr;
        text-align: left;
        white-space: pre;
        word-spacing: normal;
        -moz-tab-size: 4;
        -o-tab-size: 4;
        tab-size: 4;
        -webkit-hyphens: none;
        -moz-hyphens: none;
        -ms-hyphens: none;
        hyphens: none;
      }
      pre[class*='language-'] {
        padding: 1em;
        margin: 0.5em 0;
        overflow: auto;
      }
      :not(pre) > code[class*='language-'],
      pre[class*='language-'] {
        background: #f5f2f0;
      }
      :not(pre) > code[class*='language-'] {
        padding: 0.1em;
        border-radius: 0.3em;
      }
      .token.comment,
      .token.prolog,
      .token.doctype,
      .token.cdata {
        color: slategray;
      }
      .token.punctuation {
        color: #999;
      }
      .namespace {
        opacity: 0.7;
      }
      .token.property,
      .token.tag,
      .token.boolean,
      .token.number {
        color: #905;
      }
      .token.selector,
      .token.attr-name,
      .token.string {
        color: #690;
      }
      .token.operator,
      .token.entity,
      .token.url,
      .language-css .token.string,
      .style .token.string {
        color: #a67f59;
        background: hsla(0, 0%, 100%, 0.5);
      }
      .token.atrule,
      .token.attr-value,
      .token.keyword {
        color: #07a;
      }
      .token.regex,
      .token.important {
        color: #e90;
      }
      .token.important {
        font-weight: bold;
      }
      .token.entity {
        cursor: help;
      }
      div.description {
        margin: 14px 0;
        padding-top: 14px;
        border-bottom: 1px solid #eee;
      }
      .tags {
      }
      .ctx-type {
        display: inline-block;
        margin-right: 0.5em;
        //- float:right; margin-top:8px
      }

      footer iframe {
        vertical-align: middle;
      }
     
   
   
     
       
         
           Doxx 
           
             
           
         
       
     
     
       
         elasticlunr 
         
       
     
     
       
         
           
             Main 
             configuration.js 
             document_store.js 
             elasticlunr.js 
             event_emitter.js 
             index.js 
             inverted_index.js 
             pipeline.js 
             sorted_set.js 
             stemmer.js 
             stop_word_filter.js 
             tokenizer.js 
             trimmer.js 
             utils.js 
           
           
             
           
         
         
           
             Elasticlunr.js 
             
               
             
             
              Elasticlunr.js is a lightweight full-text search engine developed
              in JavaScript for browser search and offline search. Elasticlunr.js
              is developed based on Lunr.js, but more flexible than lunr.js.
              Elasticlunr.js provides Query-Time boosting, field search, more
              rational scoring/ranking methodology, fast computation speed and
              so on. Elasticlunr.js is a bit like Solr, but much smaller
              and not as bright, but also provide flexible configuration,
              query-time boosting, field search and other features.
             
             Why You Need Lightweight Offline Search? 
             
               
                In some system, you don&#39;t want to deploy any
                 complex full-text search engine (such as
                Lucence, Elasticsearch, Sphinx, etc.), you only want to provide
                some static web pages and provide search functionality , then
                you could build index in previous and load index in client
                side(such as Browser).
               
               
                Provide offline search functionality. For some documents, user
                usually download these documents, you could build index and put
                index in the documents package, then provide offline search
                functionality.
               
               
                For some limited or restricted network, such WAN or LAN, offline
                search is a better choice.
               
               
                For mobile device, Iphone or Android phone, network traffic
                maybe very expensive, then provide offline search is a good
                choice.
               
               
                If you want to provide search functionality in your Node.js
                system, and you don&#39;t want to use a complex system, or you
                only need to support thousands of documents, then Elasticlunr.js
                is what you want to use.
               
             
             Key Features Comparing with Lunr.js 
             
               
                 Query-Time Boosting , you don&#39;t need to
                setup boosting weight in index building procedure, Query-Time
                Boosting make it more flexible that you could try different
                boosting scheme.
               
               
                 More Rational Scoring Mechanism , Elasticlunr.js
                use quite the same scoring mechanism as Elasticsearch, and also
                this scoring mechanism is used by lucene.
               
               
                 Field-Search , you could choose which field to
                index and which field to search.
               
               
                 Boolean Model , you could set which field to
                search and the boolean model for each query token, such as
                &quot;OR&quot;, &quot;AND&quot;.
               
               
                 Combined Boolean Model, TF/IDF Model and the Vector Space
                  Model , make the results ranking more reliable.
               
               
                 Fast , Elasticlunr.js removed TokenCorpus and
                Vector from lunr.js, by using combined model there is
                 no  need to compute the vector of a document and
                query string to compute similarity of query and matched
                document, this improve the search speed significantly.
               
               
                 Small Index Size , Elasticlunr.js did not store
                TokenCorpus because there is no need to compute query vector and
                document vector, then the index file is small, and also user
                could choose if they need to store the origianl JSON doc, if
                user care more about the index size, they could choose not store
                the original JSON doc, this could reduce the index size
                significantly. This is especially helpful when elasticlunr.js is
                used as offline search. The index size is about half size of
                lunr.js index file.
               
             
             Example 
             
              A very simple search index can be created using the following
              scripts:
             
             var index = elasticlunr(function () {
    this.addField(&#39;title&#39;);
    this.addField(&#39;body&#39;);
    this.setRef(&#39;id&#39;);
});
 
             Adding documents to the index is as simple as: 
             var doc1 = {
    &quot;id&quot;: 1,
    &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;,
    &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot;
}

var doc2 = {
    &quot;id&quot;: 2,
    &quot;title&quot;: &quot;Oracle released its profit report of 2015&quot;,
    &quot;body&quot;: &quot;As expected, Oracle released its profit report of 2015, during the good sales of database and hardware, Oracle&#39;s profit of 2015 reached 12.5 Billion.&quot;
}

index.addDoc(doc1);
index.addDoc(doc2);
 
             Then searching is as simple: 
             index.search(&quot;Oracle database profit&quot;);
 
             
              Also, you could do query-time boosting by passing in a
              configuration.
             
             index.search(&quot;Oracle database profit&quot;, {
    fields: {
        title: {boost: 2},
        body: {boost: 1}
    }
});
 
             
              This returns a list of matching documents with a score of how
              closely they match the search query:
             
             [{
    &quot;ref&quot;: 1,
    &quot;score&quot;: 0.5376053707962494
},
{
    &quot;ref&quot;: 2,
    &quot;score&quot;: 0.5237481076838757
}]
 
             
              If user do not want to store the original JSON documents, they
              could use the following setting:
             
             var index = elasticlunr(function () {
    this.addField(&#39;title&#39;);
    this.addField(&#39;body&#39;);
    this.setRef(&#39;id&#39;);
    this.saveDocument(false);
});
 
             
              Then elasticlunr.js will not store the JSON documents, this will
              reduce the index size, but also bring some inconvenience such as
              update a document or delete a document by document id or
              reference. Actually most of the time user will not udpate or
              delete a document from index.
             
             
               API documentation 
              is available, as well as a
               full working example .
             
             Description 
             
              Elasticlunr.js is developed based on Lunr.js, but more flexible
              than lunr.js. Elasticlunr.js provides Query-Time Boosting, Field
              Search, more rational scoring/ranking methodology, flexible
              configuration and so on. A bit like Solr, but much smaller
              and not as bright, but also provide flexible configuration,
              query-time boosting, field search, etc.
             
             Installation 
             
              Simply include the elasticlunr.js source file in the page that you
              want to use it. Elasticlunr.js is supported in all modern
              browsers.
             
             
              Browsers that do not support ES5 will require a JavaScript shim
              for Elasticlunr.js to work. You can either use
               Augment.js ,
               ES5-Shim  or
              any library that patches old browsers to provide an ES5 compatible
              JavaScript environment.
             
             Documentation 
             
              This part only contain important apects of elasticlunr.js, for the
              whole documentation, please go to
               API documentation .
             
             1. Build Index 
             
              When you first create a index instance, you need to specify which
              field you want to index. If you did not specify which field to
              index, then no field will be searchable for your documents. You
              could specify fields by:
             
             var index = elasticlunr(function () {
    this.addField(&#39;title&#39;);
    this.addField(&#39;body&#39;);
    this.setRef(&#39;id&#39;);
});
 
             
              You could also set the document reference by
               this.setRef(&#39;id&#39;) , if you did not set
              document ref, elasticlunr.js will use
               &#39;id&#39;  as default.
             
             You could do the above index setup as followings: 
             var index = elasticlunr();
index.addField(&#39;title&#39;);
index.addField(&#39;body&#39;);
index.setRef(&#39;id&#39;);
 
             
              Also you could choose not store the original JSON document to
              reduce the index size by:
             
             var index = elasticlunr();
index.addField(&#39;title&#39;);
index.addField(&#39;body&#39;);
index.setRef(&#39;id&#39;);
index.saveDocument(false);
 
             2. Add document to index 
             
              Add document to index is very simple, just prepare you document in
              JSON format, then add it to index.
             
             var doc1 = {
    &quot;id&quot;: 1,
    &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;,
    &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot;
}

var doc2 = {
    &quot;id&quot;: 2,
    &quot;title&quot;: &quot;Oracle released its profit report of 2015&quot;,
    &quot;body&quot;: &quot;As expected, Oracle released its profit report of 2015, during the good sales of database and hardware, Oracle&#39;s profit of 2015 reached 12.5 Billion.&quot;
}

index.addDoc(doc1);
index.addDoc(doc2);
 
             
              If your JSON document contains field that not configured in index,
              then that field will not be indexed, which means that field is not
              searchable.
             
             3. Remove document from index 
             
              Elasticlunr.js support remove a document from index, just provide
              JSON document to
               elasticlunr.Index.prototype.removeDoc()  function.
             
             For example: 
             var doc = {
    &quot;id&quot;: 1,
    &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;,
    &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot;
}

index.removeDoc(doc);
 
             
              Remove a document will remove each token of that document&#39;s
              each field from field-specified inverted index.
             
             4. Update a document in index 
             
              Elasticlunr.js support update a document in index, just provide
              JSON document to
               elasticlunr.Index.prototype.update()  function.
             
             For example: 
             var doc = {
    &quot;id&quot;: 1,
    &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;,
    &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot;
}

index.update(doc);
 
             5. Query from Index 
             
              Elasticlunr.js provides flexible query configuration, supports
              query-time boosting and Boolean logic setting. You could
              setup a configuration tell elasticlunr.js how to do query-time
              boosting, which field to search in, how to do the boolean
              logic. Or you could just use it by simply provide a query
              string, this will aslo works perfectly because the scoring
              mechanism is very efficient.
             
             5.1 Simple Query 
             
               Because elasticlunr.js has a very perfect scoring mechanism, so
                for most of your requirement, simple search would be easy to
                meet your requirement. 
             
             index.search(&quot;Oracle database profit&quot;);
 
             
              Output is a results array, each element of results array is an
              Object contain a  ref  field and a
               score  field. ref  is the document
              reference. score  is the similarity measurement.
             
             Results array is sorted descent by  score . 
             5.2 Configuration Query 
             5.2.1  Query-Time Boosting 
             
              Setup which fields to search in by passing in a JSON
              configuration, and setup boosting for each search field. If
              you setup this configuration, then elasticlunr.js will only search
              the query string in the specified fields with boosting weight.
             
             
               The scoring mechanism used in elasticlunr.js is very
                complex , please goto
               details 
              for more information.
             
             index.search(&quot;Oracle database profit&quot;, {
    fields: {
        title: {boost: 2},
        body: {boost: 1}
    }
});
 
             5.2.2  Boolean Model 
             
              Elasticlunr.js also support boolean logic setting, if no boolean
              logic is setted, elasticlunr.js use &quot;OR&quot; logic defaulty.
              By &quot;OR&quot; default logic, elasticlunr.js could reach a high
               Recall .
             
             index.search(&quot;Oracle database profit&quot;, {
    fields: {
        title: {boost: 2},
        body: {boost: 1}
    },
    bool: &quot;OR&quot;
});
 
             
              Boolean model could be setted by global level such as the above
              setting or it could be setted by field level, if both global and
              field level contains a &quot;bool&quot; setting, field level
              setting will overwrite the global setting.
             
             index.search(&quot;Oracle database profit&quot;, {
    fields: {
        title: {boost: 2, bool: &quot;AND&quot;},
        body: {boost: 1}
    },
    bool: &quot;OR&quot;
});
 
             
              The above setting will search  title  field by
               AND  model and other fields by &quot;OR&quot;
              model. Currently if you search in multiply fields, resutls
              from each field will be merged together to give the query results.
              In the future elasticlunr will support configuration that user
              could set how to combine the results from each field, such as
              &quot;most_field&quot; or &quot;top_field&quot;.
             
             5.2.3  Token Expandation 
             
              Sometimes user want to expand a query token to increase
               RECALL , then user could set expand model to
               true  by configuration, default is
               false . For example, user query token is
              &quot;micro&quot;, and assume &quot;microwave&quot; and
              &quot;microscope&quot; are in the index, then is user choose
              expand the query token &quot;micro&quot; to increase
               RECALL , both &quot;microwave&quot; and
              &quot;microscope&quot; will be returned and search in the
              index. The query results from expanded tokens are penalized
              because they are not exactly the same as the query token.
             
             index.search(&quot;micro&quot;, {
    fields: {
        title: {boost: 2, bool: &quot;AND&quot;},
        body: {boost: 1}
    },
    bool: &quot;OR&quot;,
    expand: true
});
 
             
              Field level expand configuration will overwrite global expand
              configuration.
             
             index.search(&quot;micro&quot;, {
    fields: {
        title: {
            boost: 2,
            bool: &quot;AND&quot;,
            expand: false
        },
        body: {boost: 1}
    },
    bool: &quot;OR&quot;,
    expand: true
});
 
             6. Add customized stop words 
             
              Elasticlunr.js contains some default stop words of English, such
              as:
             
             
               a 
               about 
               an 
               all 
               also 
               and 
               any 
               but 
               the 
               ... 
             
             
              Defaultly elasticlunr.js contains  120  stop words,
              user could decide not use these default stop words or add
              customized stop words.
             
             6.1 Remove default stop words 
             You could remove default stop words simply as: 
             elasticlunr.clearStopWords();
 
             6.2 Add customized stop words 
             User could add a list of customized stop words. 
             var customized_stop_words = [&#39;an&#39;, &#39;hello&#39;, &#39;xyzabc&#39;];
elasticlunr.addStopWords(customized_stop_words);
 
             7. Use elasticlunr in Node.js 
             
              Elasticlunr support Node.js, you could use elastilunr in node.js
              as a node-module.
             
             Install elasticlunr by: 
             npm install elasticlunr
 
             then in your node.js project or in node.js console: 
             var elasticlunr = require(&#39;elasticlunr&#39;);

var index = elasticlunr(function () {
    this.addField(&#39;title&#39;)
    this.addField(&#39;body&#39;)
});

var doc1 = {
    &quot;id&quot;: 1,
    &quot;title&quot;: &quot;Oracle released its latest database Oracle 12g&quot;,
    &quot;body&quot;: &quot;Yestaday Oracle has released its new database Oracle 12g, this would make more money for this company and lead to a nice profit report of annual year.&quot;
}

var doc2 = {
    &quot;id&quot;: 2,
    &quot;title&quot;: &quot;Oracle released its profit report of 2015&quot;,
    &quot;body&quot;: &quot;As expected, Oracle released its profit report of 2015, during the good sales of database and hardware, Oracle&#39;s profit of 2015 reached 12.5 Billion.&quot;
}

index.addDoc(doc1);
index.addDoc(doc2);

index.search(&quot;Oracle database profit&quot;);
 
             Other Languages 
             
              Default supported language of elasticlunr.js is English, if you
              want to use elasticlunr.js to index other language documents, then
              you need to use elasticlunr.js combined with
               lunr-languages .
             
             Other languages example in Browser 
             
              Suppose you are using  elasticlunr.js  in browser
              for other languages, you could download the corresponding language
              support from
               lunr-languages , then include the scripts as:
             
             &lt;script src=&quot;lunr.stemmer.support.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;lunr.de.js&quot;&gt;&lt;/script&gt;
 
             then, you could use elasticlunr.js as normal: 
             var index = elasticlunr(function () {
    // use the language (de)
    this.use(elasticlunr.de);
    // then, the normal elasticlunr index initialization
    this.addField(&#39;title&#39;)
    this.addField(&#39;body&#39;)
});
 
             Pay attention to the special code: 
                 this.use(elasticlunr.de);
 
             
              If you are using other language, such as
               es (Spanish), download the corresponding
               lunr.es.js  file and
               lunr.stemmer.support.js , and change the above line
              to:
             
                 this.use(elasticlunr.es);
 
             Other languages example in Node.js 
             
              Suppose you are using  elasticlunr.js  in
               Node.js  for other languages, you could download
              the corresponding language support from
               lunr-languages , put the files  lunr.es.js  file and
               lunr.stemmer.support.js  in your project, then in your
               Node.js  module, use
               elasticlunr.js  as:
             
             var elasticlunr = require(&#39;elasticlunr&#39;);
require(&#39;./lunr.stemmer.support.js&#39;)(elasticlunr);
require(&#39;./lunr.de.js&#39;)(elasticlunr);

var index = elasticlunr(function () {
    // use the language (de)
    this.use(elasticlunr.de);
    // then, the normal elasticlunr index initialization
    this.addField(&#39;title&#39;)
    this.addField(&#39;body&#39;)
});
 
             
              For more details, please go to
               lunr-languages .
             
             Contributing 
             
              See the
               CONTRIBUTING.mdown  file .
             
           
         
       
     
     
       
         
          Documentation generated with
           Doxx   created by
           Francois-Guillaume Ribreau
           
         
         
          Doxx is sponsored by
           Bringr
           
          and
           Redsmin 
         
         Theme borrowed from Twitter Bootstrap 
       
     
     
     
     
     
     
     
     
     
     
      /**
       * Prism: Lightweight, robust, elegant syntax highlighting
       * MIT license http://www.opensource.org/licenses/mit-license.php/
       * @author Lea Verou http://lea.verou.me
       */ (function() {
        var e = /\blang(?:uage)?-(?!\*)(\w+)\b/i,
          t = (self.Prism = {
            util: {
              type: function(e) {
                return Object.prototype.toString
                  .call(e)
                  .match(/\[object (\w+)\]/)[1];
              },
              clone: function(e) {
                var n = t.util.type(e);
                switch (n) {
                  case 'Object':
                    var r = {};
                    for (var i in e)
                      e.hasOwnProperty(i) && (r[i] = t.util.clone(e[i]));
                    return r;
                  case 'Array':
                    return e.slice();
                }
                return e;
              }
            },
            languages: {
              extend: function(e, n) {
                var r = t.util.clone(t.languages[e]);
                for (var i in n) r[i] = n[i];
                return r;
              },
              insertBefore: function(e, n, r, i) {
                i = i || t.languages;
                var s = i[e],
                  o = {};
                for (var u in s)
                  if (s.hasOwnProperty(u)) {
                    if (u == n)
                      for (var a in r) r.hasOwnProperty(a) && (o[a] = r[a]);
                    o[u] = s[u];
                  }
                return (i[e] = o);
              },
              DFS: function(e, n) {
                for (var r in e) {
                  n.call(e, r, e[r]);
                  t.util.type(e) === 'Object' && t.languages.DFS(e[r], n);
                }
              }
            },
            highlightAll: function(e, n) {
              var r = document.querySelectorAll(
                'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
              );
              for (var i = 0, s; (s = r[i++]); )
                t.highlightElement(s, e === !0, n);
            },
            highlightElement: function(r, i, s) {
              var o,
                u,
                a = r;
              while (a && !e.test(a.className)) a = a.parentNode;
              if (a) {
                o = (a.className.match(e) || [, ''])[1];
                u = t.languages[o];
              }
              if (!u) return;
              r.className =
                r.className.replace(e, '').replace(/\s+/g, ' ') +
                ' language-' +
                o;
              a = r.parentNode;
              /pre/i.test(a.nodeName) &&
                (a.className =
                  a.className.replace(e, '').replace(/\s+/g, ' ') +
                  ' language-' +
                  o);
              var f = r.textContent;
              if (!f) return;
              f = f
                .replace(/&/g, '&amp;')
                .replace(/ </g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\u00a0/g, ' ');
              var l = { element: r, language: o, grammar: u, code: f };
              t.hooks.run('before-highlight', l);
              if (i && self.Worker) {
                var c = new Worker(t.filename);
                c.onmessage = function(e) {
                  l.highlightedCode = n.stringify(JSON.parse(e.data));
                  l.element.innerHTML = l.highlightedCode;
                  s && s.call(l.element);
                  t.hooks.run('after-highlight', l);
                };
                c.postMessage(
                  JSON.stringify({ language: l.language, code: l.code })
                );
              } else {
                l.highlightedCode = t.highlight(l.code, l.grammar);
                l.element.innerHTML = l.highlightedCode;
                s && s.call(r);
                t.hooks.run('after-highlight', l);
              }
            },
            highlight: function(e, r) {
              return n.stringify(t.tokenize(e, r));
            },
            tokenize: function(e, n) {
              var r = t.Token,
                i = [e],
                s = n.rest;
              if (s) {
                for (var o in s) n[o] = s[o];
                delete n.rest;
              }
              e: for (var o in n) {
                if (!n.hasOwnProperty(o) || !n[o]) continue;
                var u = n[o],
                  a = u.inside,
                  f = !!u.lookbehind || 0;
                u = u.pattern || u;
                for (var l = 0; l  < i.length; l++) {
                  var c = i[l];
                  if (i.length > e.length) break e;
                  if (c instanceof r) continue;
                  u.lastIndex = 0;
                  var h = u.exec(c);
                  if (h) {
                    f && (f = h[1].length);
                    var p = h.index - 1 + f,
                      h = h[0].slice(f),
                      d = h.length,
                      v = p + d,
                      m = c.slice(0, p + 1),
                      g = c.slice(v + 1),
                      y = [l, 1];
                    m && y.push(m);
                    var b = new r(o, a ? t.tokenize(h, a) : h);
                    y.push(b);
                    g && y.push(g);
                    Array.prototype.splice.apply(i, y);
                  }
                }
              }
              return i;
            },
            hooks: {
              all: {},
              add: function(e, n) {
                var r = t.hooks.all;
                r[e] = r[e] || [];
                r[e].push(n);
              },
              run: function(e, n) {
                var r = t.hooks.all[e];
                if (!r || !r.length) return;
                for (var i = 0, s; (s = r[i++]); ) s(n);
              }
            }
          }),
          n = (t.Token = function(e, t) {
            this.type = e;
            this.content = t;
          });
        n.stringify = function(e) {
          if (typeof e == 'string') return e;
          if (Object.prototype.toString.call(e) == '[object Array]') {
            for (var r = 0; r  < e.length; r++) e[r] = n.stringify(e[r]);
            return e.join('');
          }
          var i = {
            type: e.type,
            content: n.stringify(e.content),
            tag: 'span',
            classes: ['token', e.type],
            attributes: {}
          };
          i.type == 'comment' && (i.attributes.spellcheck = 'true');
          t.hooks.run('wrap', i);
          var s = '';
          for (var o in i.attributes)
            s += o + '="' + (i.attributes[o] || '') + '"';
          return (
            ' <' +
            i.tag +
            ' class="' +
            i.classes.join(' ') +
            '" ' +
            s +
            '>' +
            i.content +
            ' </' +
            i.tag +
            '>'
          );
        };
        if (!self.document) {
          self.addEventListener(
            'message',
            function(e) {
              var n = JSON.parse(e.data),
                r = n.language,
                i = n.code;
              self.postMessage(JSON.stringify(t.tokenize(i, t.languages[r])));
              self.close();
            },
            !1
          );
          return;
        }
        var r = document.getElementsByTagName('script');
        r = r[r.length - 1];
        if (r) {
          t.filename = r.src;
          document.addEventListener &&
            !r.hasAttribute('data-manual') &&
            document.addEventListener('DOMContentLoaded', t.highlightAll);
        }
      })();
      Prism.languages.markup = {
        comment: /&lt;!--[\w\W]*?--(&gt;|&gt;)/g,
        prolog: /&lt;\?.+?\?&gt;/,
        doctype: /&lt;!DOCTYPE.+?&gt;/,
        cdata: /&lt;!\[CDATA\[[\w\W]+?]]&gt;/i,
        tag: {
          pattern: /&lt;\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|\w+))?\s*)*\/?&gt;/gi,
          inside: {
            tag: {
              pattern: /^&lt;\/?[\w:-]+/i,
              inside: { punctuation: /^&lt;\/?/, namespace: /^[\w-]+?:/ }
            },
            'attr-value': {
              pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi,
              inside: { punctuation: /=|&gt;|"/g }
            },
            punctuation: /\/?&gt;/g,
            'attr-name': {
              pattern: /[\w:-]+/g,
              inside: { namespace: /^[\w-]+?:/ }
            }
          }
        },
        entity: /&amp;#?[\da-z]{1,8};/gi
      };
      Prism.hooks.add('wrap', function(e) {
        e.type === 'entity' &&
          (e.attributes.title = e.content.replace(/&amp;/, '&'));
      });
      Prism.languages.css = {
        comment: /\/\*[\w\W]*?\*\//g,
        atrule: /@[\w-]+?(\s+[^;{]+)?(?=\s*{|\s*;)/gi,
        url: /url\((["']?).*?\1\)/gi,
        selector: /[^\{\}\s][^\{\}]*(?=\s*\{)/g,
        property: /(\b|\B)[a-z-]+(?=\s*:)/gi,
        string: /("|')(\\?.)*?\1/g,
        important: /\B!important\b/gi,
        ignore: /&(lt|gt|amp);/gi,
        punctuation: /[\{\};:]/g
      };
      Prism.languages.markup &&
        Prism.languages.insertBefore('markup', 'tag', {
          style: {
            pattern: /(&lt;| <)style[\w\W]*?(>|&gt;)[\w\W]*?(&lt;| <)\/style(>|&gt;)/gi,
            inside: {
              tag: {
                pattern: /(&lt;| <)style[\w\W]*?(>|&gt;)|(&lt;| <)\/style(>|&gt;)/gi,
                inside: Prism.languages.markup.tag.inside
              },
              rest: Prism.languages.css
            }
          }
        });
      Prism.languages.clike = {
        comment: {
          pattern: /(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*?(\r?\n|$))/g,
          lookbehind: !0
        },
        string: /("|')(\\?.)*?\1/g,
        keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|catch|finally|null|break|continue)\b/g,
        boolean: /\b(true|false)\b/g,
        number: /\b-?(0x)?\d*\.?[\da-f]+\b/g,
        operator: /[-+]{1,2}|!|=?&lt;|=?&gt;|={1,2}|(&amp;){1,2}|\|?\||\?|\*|\//g,
        ignore: /&(lt|gt|amp);/gi,
        punctuation: /[{}[\];(),.:]/g
      };
      Prism.languages.javascript = Prism.languages.extend('clike', {
        keyword: /\b(var|let|if|else|while|do|for|return|in|instanceof|function|new|with|typeof|try|catch|finally|null|break|continue)\b/g,
        number: /\b(-?(0x)?\d*\.?[\da-f]+|NaN|-?Infinity)\b/g
      });
      Prism.languages.insertBefore('javascript', 'keyword', {
        regex: {
          pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,
          lookbehind: !0
        }
      });
      Prism.languages.markup &&
        Prism.languages.insertBefore('markup', 'tag', {
          script: {
            pattern: /(&lt;| <)script[\w\W]*?(>|&gt;)[\w\W]*?(&lt;| <)\/script(>|&gt;)/gi,
            inside: {
              tag: {
                pattern: /(&lt;| <)script[\w\W]*?(>|&gt;)|(&lt;| <)\/script(>|&gt;)/gi,
                inside: Prism.languages.markup.tag.inside
              },
              rest: Prism.languages.javascript
            }
          }
        });
     
     
     
      $(function() {
        var $window = $(window);
        $('.scrollspy .nav').affix({
          offset: {
            top: function() {
              return $window.width()  <= 980 ? 480 : 400;
            },
            bottom: 50
          }
        });
      });
     
   
 
 

